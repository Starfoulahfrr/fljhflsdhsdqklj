from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes, MessageHandler, filters
from telegram.constants import ParseMode
import sqlite3
import random
from datetime import datetime
import asyncio
from asyncio import Lock

update_lock = Lock()

active_games = {}


class DB:
    @staticmethod
    def get_connection():
        return sqlite3.connect("blackjack.db")

    @staticmethod
    def is_player_in_game(player_id):
        for game in active_games.values():
            if player_id in (game.host_id, game.opponent_id):
                return True
        return False

    @staticmethod
    def get_balance(user_id):
        conn = DB.get_connection()
        c = conn.cursor()
        c.execute('SELECT balance FROM users WHERE user_id = ?', (user_id,))
        result = c.fetchone()
        conn.close()
        return result[0] if result else 0

    @staticmethod
    def set_balance(user_id, new_balance):
        conn = DB.get_connection()
        c = conn.cursor()
        c.execute('UPDATE users SET balance = ? WHERE user_id = ?', (new_balance, user_id))
        conn.commit()
        conn.close()

    @staticmethod
    def get_username(user_id):
        conn = DB.get_connection()
        c = conn.cursor()
        c.execute('SELECT username FROM users WHERE user_id = ?', (user_id,))
        result = c.fetchone()
        conn.close()
        return result[0] if result else str(user_id)

# Remplacer l'import de Database par notre classe DB
db = DB()

class Connect4Game:
    def __init__(self, chat_id, host_id, bet_amount, thread_id=None):
        self.chat_id = chat_id
        self.host_id = host_id
        self.opponent_id = None
        self.bet_amount = bet_amount
        self.thread_id = thread_id
        self.message_id = None
        self.current_turn = None
        self.is_finished = False
        self.created_at = datetime.now()
        self.last_move_time = datetime.now()
        self.warning_sent = False
        self.afk_messages = []
        
        # Initialiser la grille 6x7
        self.grid = [["‚ö™Ô∏è" for _ in range(7)] for _ in range(6)]

    def make_move(self, column, player_id):
        # V√©rifier si c'est le bon tour
        if player_id != self.current_turn:
            return False, "Ce n'est pas votre tour!"

        # Trouver la premi√®re position libre dans la colonne
        row = -1
        for i in range(5, -1, -1):
            if self.grid[i][column] == "‚ö™Ô∏è":
                row = i
                break

        if row == -1:
            return False, "Cette colonne est pleine!"

        # Placer le jeton
        symbol = "üî¥" if player_id == self.host_id else "üü°"
        self.grid[row][column] = symbol

        # V√©rifier la victoire
        if self.check_win(row, column, symbol):
            self.is_finished = True
            return True, player_id

        # V√©rifier l'√©galit√©
        if self.is_board_full():
            self.is_finished = True
            return True, "draw"

        # Changer de tour
        self.current_turn = self.opponent_id if player_id == self.host_id else self.host_id
        return True, None

    def check_win(self, row, col, symbol):
        # Directions : horizontal, vertical, diagonal descendant, diagonal montant
        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]
    
        for dx, dy in directions:
            count = 0
            # V√©rifier dans les deux sens
            for direction in [-1, 1]:
                nx, ny = row, col
                while 0 <= nx < 6 and 0 <= ny < 7 and self.grid[nx][ny] == symbol:
                    count += 1
                    nx += dx * direction
                    ny += dy * direction
            if count >= 5:  # 5 car on compte la position actuelle deux fois
                return True
        return False

    def is_board_full(self):
        return all(self.grid[0][col] != "‚ö™Ô∏è" for col in range(7))

    def get_display_message(self):
        if not self.opponent_id:
            time_left = 300 - (datetime.now() - self.created_at).total_seconds()
            if time_left <= 0:
                return "‚è∞ *Cette partie a expir√©!*"
                
            minutes = int(time_left // 60)
            seconds = int(time_left % 60)
            
            return (
                "üéÆ *NOUVELLE PARTIE DE PUISSANCE 4!*\n\n"
                f"üë§ *H√¥te:* {db.get_username(self.host_id)}\n"
                f"üí∞ *Mise:* {self.bet_amount:,} üíµ\n"
                f"‚è∞ *Expire dans:* {minutes}:{seconds:02d}\n\n"
                "*Comment jouer:*\n"
                "üî¥ Alignez 4 jetons\n"
                "üü° Horizontalement, verticalement ou en diagonale"
            )
        else:
            current_player = db.get_username(self.current_turn)
            return (
                "üéÆ *PUISSANCE 4 EN COURS*\n\n"
                f"üî¥ *{db.get_username(self.host_id)}* VS üü° *{db.get_username(self.opponent_id)}*\n"
                f"üí∞ *Mise:* {self.bet_amount:,} üíµ\n\n"
                f"üéØ *Au tour de:* {current_player}"
            )

# Constante pour le thread autoris√©
GAME_THREAD_ID = 40279  # Remplacez par l'ID de votre thread de jeu

async def cmd_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # V√©rifier si la commande est dans le bon thread
    if not update.message.is_topic_message or update.message.message_thread_id != GAME_THREAD_ID:
        try:
            await update.message.delete()
        except Exception as e:
            print(f"Erreur lors de la suppression du message: {e}")
        return

    user_id = update.effective_user.id
    
    # Chercher une partie o√π l'utilisateur est l'h√¥te
    for game_id, game in list(active_games.items()):
        if game.host_id == user_id and not game.opponent_id:
            # Rembourser la mise
            db.set_balance(user_id, db.get_balance(user_id) + game.bet_amount)
            
            try:
                await context.bot.edit_message_text(
                    chat_id=game.chat_id,
                    message_id=game.message_id,
                    text="‚ùå *Partie annul√©e*\nLa mise a √©t√© rembours√©e.",
                    parse_mode=ParseMode.MARKDOWN,
                    reply_markup=InlineKeyboardMarkup([])
                )
                del active_games[game_id]
                return
            except Exception as e:
                print(f"Erreur lors de l'annulation de la partie: {e}")

    await update.message.reply_text(
        "‚ùå Vous n'avez pas de partie en attente √† annuler!"
    )
    
async def cmd_p4(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Supprimer la commande /p4
    try:
        await update.message.delete()
    except Exception as e:
        print(f"Erreur lors de la suppression de la commande: {e}")

    # V√©rifier si la commande est dans le bon thread
    if not update.message.is_topic_message or update.message.message_thread_id != GAME_THREAD_ID:
        return

    # Fonction helper pour envoyer et supprimer les messages d'erreur
    async def send_temp_error(text, delete_after=3):  # 3 secondes par d√©faut
        try:
            error_message = await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=text,
                message_thread_id=GAME_THREAD_ID
            )
            # Programmer la suppression
            await asyncio.sleep(delete_after)
            await error_message.delete()
        except Exception as e:
            print(f"Erreur lors de l'envoi/suppression du message temporaire: {e}")

    try:
        # V√©rifier si la commande a un argument (mise)
        if not context.args:
            await send_temp_error(
                "‚ùå Veuillez sp√©cifier une mise!\n"
                "Usage: /p4 <mise>"
            )
            return

        # V√©rifier si le joueur est d√©j√† dans une partie
        if db.is_player_in_game(update.effective_user.id):
            await send_temp_error(
                "‚ùå Vous avez d√©j√† une partie en cours!\n"
                "Terminez ou annulez votre partie actuelle avant d'en cr√©er une nouvelle."
            )
            return

        # V√©rifier si la mise est un nombre valide
        try:
            bet = int(context.args[0])
        except ValueError:
            await send_temp_error("‚ùå La mise doit √™tre un nombre!")
            return

        # V√©rifier si la mise est positive
        if bet <= 0:
            await send_temp_error("‚ùå La mise doit √™tre positive!")
            return

        # V√©rifier le solde du joueur
        player_balance = db.get_balance(update.effective_user.id)
        if player_balance < bet:
            await send_temp_error(
                f"‚ùå Solde insuffisant!\n"
                f"üí∞ Votre solde: {player_balance:,} üíµ"
            )
            return

        # Cr√©er une nouvelle partie
        game = Connect4Game(
            update.effective_chat.id,
            update.effective_user.id,
            bet,
            update.message.message_thread_id if update.message.is_topic_message else None
        )

        # Cr√©er le clavier
        keyboard = [
            [InlineKeyboardButton("‚úÖ Rejoindre", callback_data="join")],
            [InlineKeyboardButton("‚ùå Annuler", callback_data="cancel")]
        ]

        # Envoyer le message initial
        message = await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=game.get_display_message(),
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode=ParseMode.MARKDOWN,
            message_thread_id=GAME_THREAD_ID
        )

        game.message_id = message.message_id
        active_games[message.message_id] = game

    except Exception as e:
        print(f"Erreur dans cmd_p4: {e}")
        await send_temp_error("‚ùå Une erreur est survenue!")

async def button_click(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    try:
        game = active_games.get(query.message.message_id)
        if not game:
            await query.answer("‚ùå Cette partie n'existe plus!")
            return

        if query.data == "cancel":
            # V√©rifier si c'est bien l'h√¥te qui annule
            if query.from_user.id != game.host_id:
                await query.answer("‚ùå Seul l'h√¥te peut annuler la partie!", show_alert=True)
                return
    
            if game.opponent_id:
                await query.answer("‚ùå Impossible d'annuler une partie en cours!", show_alert=True)
                return

            # Mettre √† jour le message
            await query.edit_message_text(
                "‚ùå *Partie annul√©e*\nTapez /p4 <mise> pour une nouvelle partie!",
                parse_mode=ParseMode.MARKDOWN
            )
    
            # Supprimer la partie
            del active_games[query.message.message_id]
            await query.answer("Partie annul√©e")
            return

        if query.data == "join":
            if game.opponent_id:
                await query.answer("‚ùå Cette partie est d√©j√† compl√®te!")
                return

            if query.from_user.id == game.host_id:
                await query.answer("‚ùå Vous ne pouvez pas jouer contre vous-m√™me!")
                return

            if db.is_player_in_game(query.from_user.id):
                await query.answer("‚ùå Vous avez d√©j√† une partie en cours!")
                return

            # V√©rifier le solde du joueur
            player_balance = db.get_balance(query.from_user.id)
            if player_balance < game.bet_amount:
                await query.answer("‚ùå Solde insuffisant!")
                return

            # D√©duire la mise
            db.set_balance(query.from_user.id, player_balance - game.bet_amount)

            # Configurer la partie
            game.opponent_id = query.from_user.id
            game.current_turn = game.host_id
            game.last_move_time = datetime.now()

            # Cr√©er le clavier de jeu
            keyboard = []
            for i in range(7):
                keyboard.append(InlineKeyboardButton(str(i+1), callback_data=f"move_{i}"))

            await query.message.edit_text(
                game.get_display_message(),
                reply_markup=InlineKeyboardMarkup([keyboard]),
                parse_mode=ParseMode.MARKDOWN
            )
            await query.answer()

        elif query.data.startswith("move_"):
            if not game.opponent_id:
                await query.answer("‚ùå Attendez qu'un joueur rejoigne!")
                return

            if query.from_user.id != game.current_turn:
                await query.answer("‚ùå Ce n'est pas votre tour!")
                return

            if game.is_finished:
                await query.answer("‚ùå La partie est termin√©e!")
                return

            # Faire le coup
            column = int(query.data.split("_")[1])
            valid_move, result = game.make_move(column, query.from_user.id)

            if not valid_move:
                await query.answer(result)
                return

            # Mettre √† jour le temps du dernier coup
            game.last_move_time = datetime.now()
            game.warning_sent = False

            # Supprimer les messages AFK pr√©c√©dents
            for msg_id in game.afk_messages:
                try:
                    await context.bot.delete_message(
                        chat_id=game.chat_id,
                        message_id=msg_id
                    )
                except Exception as e:
                    print(f"Erreur lors de la suppression du message AFK {msg_id}: {e}")
            game.afk_messages = []

            if result is not None:  # Partie termin√©e
                winner_id = result
                # Garder le clavier actuel pour l'affichage
                display_keyboard = []
                # Afficher la grille finale
                for row in game.grid:
                    display_keyboard.append([InlineKeyboardButton(cell, callback_data="dummy") for cell in row])

                if winner_id == "draw":
                    # Rembourser les deux joueurs
                    db.set_balance(game.host_id, db.get_balance(game.host_id) + game.bet_amount)
                    db.set_balance(game.opponent_id, db.get_balance(game.opponent_id) + game.bet_amount)
                    final_message = (
                        "ü§ù *Match nul!*\n\n"
                        f"üî¥ *{db.get_username(game.host_id)}* VS üü° *{db.get_username(game.opponent_id)}*\n"
                        "Les mises ont √©t√© rembours√©es.\n\n"
                        "Tapez /p4 <mise> pour une nouvelle partie!"
                    )
                else:
                    winner_name = db.get_username(winner_id)
                    # Le gagnant re√ßoit la mise totale
                    db.set_balance(winner_id, db.get_balance(winner_id) + game.bet_amount * 2)
                    final_message = (
                        "üéÆ *Partie termin√©e!* üéÆ\n\n"
                        f"üëë *Gagnant:* {winner_name}\n"
                        f"üí∞ Gains: +{game.bet_amount * 2:,} üíµ\n\n"
                        "Tapez /p4 <mise> pour une nouvelle partie!"
                    )

                await query.message.edit_text(
                    final_message,
                    parse_mode=ParseMode.MARKDOWN,
                    reply_markup=InlineKeyboardMarkup(display_keyboard)
                )
                del active_games[query.message.message_id]
            else:
                # Mettre √† jour l'affichage
                keyboard = []
                # Afficher la grille
                for row in game.grid:
                    keyboard.append([InlineKeyboardButton(cell, callback_data="dummy") for cell in row])
                # Ajouter les boutons de colonnes
                keyboard.append([InlineKeyboardButton(str(i+1), callback_data=f"move_{i}") for i in range(7)])

                await query.message.edit_text(
                    game.get_display_message(),
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode=ParseMode.MARKDOWN
                )

            await query.answer()

    except Exception as e:
        print(f"Erreur dans button_click: {e}")
        await query.answer("‚ùå Une erreur est survenue!")

async def check_expired_games(context: ContextTypes.DEFAULT_TYPE):
    for game_id, game in list(active_games.items()):
        if not game.opponent_id:
            current_time = datetime.now()
            if (current_time - game.created_at).total_seconds() > 300:  # 5 minutes
                try:
                    await context.bot.edit_message_text(
                        chat_id=game.chat_id,
                        message_id=game.message_id,
                        text="‚è∞ *Cette partie a expir√©!*\n\nTapez /p4 <mise> pour une nouvelle partie!",
                        parse_mode=ParseMode.MARKDOWN,
                        reply_markup=InlineKeyboardMarkup([])
                    )
                    del active_games[game_id]
                except Exception as e:
                    print(f"Erreur lors de l'expiration d'une partie: {e}")

async def check_afk_players(context: ContextTypes.DEFAULT_TYPE):
    for game_id, game in list(active_games.items()):
        if game.opponent_id and not game.is_finished:
            current_time = datetime.now()
            time_since_last_move = (current_time - game.last_move_time).total_seconds()
            
            # Premi√®re alerte √† 20 secondes
            if time_since_last_move > 20 and not game.warning_sent:
                game.warning_sent = True
                current_player = db.get_username(game.current_turn)
                warning_message = (
                    f"‚ö†Ô∏è *Attention {current_player}*\n"
                    "Il vous reste 10 secondes pour jouer\n"
                    "sinon un coup al√©atoire sera jou√©!"
                )
                try:
                    message = await context.bot.send_message(
                        chat_id=game.chat_id,
                        text=warning_message,
                        message_thread_id=GAME_THREAD_ID,
                        parse_mode=ParseMode.MARKDOWN
                    )
                    game.afk_messages.append(message.message_id)
                except Exception as e:
                    print(f"Erreur lors de l'envoi du message d'avertissement: {e}")
            
            # Action apr√®s 30 secondes
            elif time_since_last_move > 30:
                # Trouver les colonnes disponibles
                available_columns = [
                    col for col in range(7)
                    if game.grid[0][col] == "‚ö™Ô∏è"  # V√©rifier si la colonne n'est pas pleine
                ]
                
                if available_columns:
                    column = random.choice(available_columns)
                    current_player = db.get_username(game.current_turn)
                    valid_move, result = game.make_move(column, game.current_turn)
                    game.last_move_time = current_time
                    game.warning_sent = False

                    # Message indiquant le coup automatique
                    afk_message = f"ü§ñ Coup al√©atoire jou√© pour {current_player} (AFK)"
                    try:
                        message = await context.bot.send_message(
                            chat_id=game.chat_id,
                            text=afk_message,
                            message_thread_id=GAME_THREAD_ID
                        )
                        game.afk_messages.append(message.message_id)
                    except Exception as e:
                        print(f"Erreur lors de l'envoi du message AFK: {e}")

                    if result is not None:
                        # Garder le clavier actuel pour l'affichage
                        display_keyboard = []
                        # Afficher la grille finale
                        for row in game.grid:
                            display_keyboard.append([InlineKeyboardButton(cell, callback_data="dummy") for cell in row])

                        if result == "draw":
                            # Rembourser les deux joueurs
                            db.set_balance(game.host_id, db.get_balance(game.host_id) + game.bet_amount)
                            db.set_balance(game.opponent_id, db.get_balance(game.opponent_id) + game.bet_amount)
                            final_message = (
                                "ü§ù *Match nul!*\n\n"
                                f"üî¥ *{db.get_username(game.host_id)}* VS üü° *{db.get_username(game.opponent_id)}*\n"
                                "Les mises ont √©t√© rembours√©es.\n\n"
                                "Tapez /p4 <mise> pour une nouvelle partie!"
                            )
                        else:
                            winner_name = db.get_username(result)
                            # Le gagnant re√ßoit la mise totale
                            db.set_balance(result, db.get_balance(result) + game.bet_amount * 2)
                            final_message = (
                                "üéÆ *Partie termin√©e!* üéÆ\n\n"
                                f"üëë *Gagnant:* {winner_name}\n"
                                f"üí∞ Gains: +{game.bet_amount * 2:,} üíµ\n\n"
                                "Tapez /p4 <mise> pour une nouvelle partie!"
                            )

                        await context.bot.edit_message_text(
                            chat_id=game.chat_id,
                            message_id=game.message_id,
                            text=final_message,
                            parse_mode=ParseMode.MARKDOWN,
                            reply_markup=InlineKeyboardMarkup(display_keyboard)
                        )
    
                        del active_games[game_id]
                    else:
                        # Mettre √† jour l'affichage
                        keyboard = []
                        for row in game.grid:
                            keyboard.append([InlineKeyboardButton(cell, callback_data="dummy") for cell in row])
                        keyboard.append([InlineKeyboardButton(str(i+1), callback_data=f"move_{i}") for i in range(7)])

                        await context.bot.edit_message_text(
                            chat_id=game.chat_id,
                            message_id=game.message_id,
                            text=game.get_display_message(),
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode=ParseMode.MARKDOWN
                        )

async def update_waiting_games(context: ContextTypes.DEFAULT_TYPE):
    if update_lock.locked():
        return
        
    async with update_lock:
        current_time = datetime.now()
        for game_id, game in list(active_games.items()):
            try:
                if not game.is_finished and not game.opponent_id:
                    time_diff = current_time - game.created_at
                    if time_diff.total_seconds() < 300:
                        keyboard = [
                            [InlineKeyboardButton("‚úÖ Rejoindre", callback_data="join")],
                            [InlineKeyboardButton("‚ùå Annuler", callback_data="cancel")]
                        ]
                        
                        try:
                            await context.bot.edit_message_text(
                                chat_id=game.chat_id,
                                message_id=game.message_id,
                                text=game.get_display_message(),
                                reply_markup=InlineKeyboardMarkup(keyboard),
                                parse_mode=ParseMode.MARKDOWN
                            )
                        except Exception as e:
                            if "Message is not modified" not in str(e):
                                print(f"Erreur lors de la mise √† jour: {e}")
                                
                        await asyncio.sleep(0.1)  # Petit d√©lai entre chaque mise √† jour
                        
            except Exception as e:
                print(f"Erreur dans update_waiting_games: {e}")

def main():
    application = Application.builder().token(TOKEN).build()
    
    # Ajouter les handlers
    application.add_handler(CommandHandler("p4", cmd_p4))
    application.add_handler(CommandHandler("cancel", cmd_cancel))
    application.add_handler(CallbackQueryHandler(button_click))

    # Ajouter les t√¢ches p√©riodiques
    application.job_queue.run_repeating(
        check_expired_games,
        interval=30,
        first=10
    )

    application.job_queue.run_repeating(
        check_afk_players,
        interval=10,
        first=5
    )

    application.job_queue.run_repeating(
        update_waiting_games,
        interval=15,  # Mise √† jour toutes les 10 secondes
        first=10
    )

    print("üéÆ Green attack pue de lab bite")
    print("Commandes disponibles:")
    print("/p4 <mise> - D√©marrer une nouvelle partie")
    
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()
